#Project Journal
###Time Review
This project formally started when my team wrote up the design file 18 days ago according to GitHub. 18 days prior to today was 09/10/15 so that is the official start of the project. The finish date of this project was 09/27/10. 

Overall, I spent about 24-40 hours a week on this project, totaling to around 80(?) hours by the end of the project. This is a very rough estimate, however. The first week, I spent the first day figuring out what the heck XML was and how to use it. I wrote the XML files for the first four simulations and the parser. Then I paired up with Dennis Xu for the front end of the the project. I coded the grid, the methods for initializing the grid depending on which simulation it was, and step functions. I also coded the Game of Life Simulation, and a pre-version of the Cell class. The second week, I spent a lot of time debugging and refactoring the code that we made in the first week. We realized that our original design wasn't flushed out enough, and that we would have to make major changes to the organizational hierarchy of our classes in order for cleaner, more efficient, working code. In addition to fixing the code, I implemented the buttons from the Buttons class, including start, stop, step forward, speed up, and slow down. I also implemented/helped implement new features and simulations, including the "show outline" and "torpoidal graph" options. 

It was easiest for me to "solve problems" so to speak. For example, figuring out how to initialize grids depending on which simulation it was (Fire had a very specific start stage, whereas Segregation could be randomly filled in) was very easy to do. I suspect this is due to the similarities with APT's, to which I have become accustomed to solving. Coding the front end was the hardest for me to do, because it doesn't have as much to do with problem solving as it does with knowing what objects to call and how to initialize them and what properties each object has. It was definitely a learning curve, but I'm glad I did it because I understand GUIs way better now. I think working with Dennis was a good use of my time because we could bounce ideas off of each other, and help each other out when we got stuck.

###TeamWork
I would say our team worked together pretty well. In the beginning when we defined roles, Steven took backend and Dennis took frontend, so I kind of got the middle "controller" part? This basically meant the XML files and parser. I ended up helping Dennis code the GUI. We definitely did not spend enough time planning out the project in the beginning. I think we met for three hours to plan, but two of those hours were used trying to figure out how to push our changes to DESIGN.md onto github. The rest of the meetings occurred concurrently with our coding. We spent a lot of time together, coding side by side on separate parts of the project. I would say that really helped to understand what the others were doing and make more informed design decisions. If we felt a certain design aspect was not working out, it was easy to flesh out on the spot because our partners were there with us. Thus, I would say that we did not really have "design meetings", but we had "coding meetings" where talks about design definitely occurred. 

As I've stated above, Steven was in charge of backend. He coded the simulations and cell classes. Dennis was in charge of front end. He made the GUI. I was in charge of the controller. I made the XML file and parser, grid, and initializers and helped Dennis make the GUI. I did not help Steven as much, except for implementing Game of Life for testing purposes. I felt that even if the communication we had was not always the most productive, we had a lot of it. If we were being unclear about communication, the other members (me included) were always willing to discuss and explain. In terms of working together, we did not encounter too much hardship. We were all willing to put in the time and pull our weight.

The team's plan for completing the project was wishy-washy in the beginning. None of us had a really solid idea of what needed to be done and who should take on those roles. We had a semblance of a plan that we thought would work, but when I started coding, I quickly realized there were many factors we did not take into account. We arbitrarily chose roles based on interest. The plan died against the project's extensions, but the team roles held up pretty well. Although we helped Steven out with the backend on the second sprint, he managed to fix up the code from the second sprint and further it for the third sprint by himself. 

###Commits
I committed when my team members needed the code I had written, or I had accomplished something. I would say I tried not to commit if I had nothing of purpose to commit. The size of my commits was generally pretty large as a result. Unless I was debugging and managed to fix the code through refactoring. I remember having trouble coming up with commit messages while I was committing. Looking over them now, I can see that while the commit messages may not detail specifically which bug/piece of code I fixed, they do give the general idea of the topic I was working on at the moment. I managed my code in the main package. 

Commit Example 1:
This commit is entitled "Buttons, GUI, and Grid". It is a large commit because in it, I have the fixed and working button class, GUI, and grid class and helper classes. The purpose of my commit was to get a working simulation game. Previously, we had been using a badly designed GUI. This one was much more cleanly written and easier to debug/tell what was going on. Luckily, by this time, the front end and the back end were separated enough that when I pushed, I created no problems for Steven. Instead, it allowed him to test his simulations in different ways since he could now start, stop, and step through frames of the simulation. 

Commit Example 2:
This commit is entitled "slime molds extra". It is a commit solely to initialize the slime mold simulation. These were the type of commits I liked the best, where I had one clear goal and after I accomplished it, I could push that single class up, instead of everything because I changed a little bit of every class. This was a very straightforward commit, meant to help, and did not cause any problems later on.

##Conclusion
I was overall satisfied with my team. We made up for each others shortcomings and took up the slack for each other. In the first week, Steven was very busy so Dennis and I helped code (albeit not the most efficiently) the backend for him. Steven then fixed up the code that we wrote in the second week, implemented hierarchies, and extended it to include a lot of other features. On the other hand, Dennis and I pretty much worked together to code the front end. I would like to believe I contributed an equal amount to the effectiveness of our group. 

I definitely underestimated the size of this project. Many implementations that we thought would be simple (ie implementing the buttons) ended up being a larger problem than we thought. However, having worked through the front end before will definitely help if I have to do it again in the future. I will overestimate the time needed for everything -- I think that's an effective way of ensuring I'll always have enough time. By the end of the project, there were functionalities that were not implemented that I knew how to implement, but simply did not have time to. I tried to always pull my weight in the group. I helped out others with their bugs, and took on coding areas that needed to be done (ie the graph, helping Dennis with GUI, the buttons, etc.). I kept the team informed of my progress mainly because I did most of my coding around them. I would say the parts of my code that require the most editing would be the parser for the XML and maybe some parts of the grid. I was afraid of messing things up, so instead of being efficient, I opted for security in the parser, but it lead to a lot of duplicated code. 

To be a better designer, I should start by learning more about design and starting earlier. It's hard to realize what your design will need unless you actually try to code it. Also, I need to become better at communicating my ideas and understanding other peoples' ideas. Many times, my partners and I would discuss solutions to a problem only to realize we were all thinking of the same solution the whole time, just worded differently. 

To be a better teammate, I need to become more available and do more coding outside of the team coding sessions. I also need to have more defined roles of what parts of the project I am responsible for. 

If I could work on one part right now to improve the project, I would work on binding the grid to the window because we are unable to dynamically resize the grid to fit the window. 

#Design Review
###Status
Because we spent a lot of the time coding together, the code is generally consistent in its layout, naming conventions. I would say our code is not very descriptive because any questions we had about it were answered on the spot -- thus there was no need to have descriptions interlaced in the code. We tried to name everything to be readable, and easy to understand. At least for the front end, I feel it is easy to pick up what each function's purpose is. One particular instance that sticks out to me is when I had a method that initializes the grid each, which I had named "FillGrid" because that is what it meant to me. However, my partners were obviously confused about what that naming convention meant because on more than one occasion, they asked me the purpose of the class. I ended up renaming it "ColorMatrix" which makes no sense to me, but they were able to remember its purpose better that way.

There are some "back channels" in the code that occurred simply because we were running out of time to write "good code". To make the timelines work, I think we used some global static variables. I'm still trying to figure out a way to do this without using those. There were definitely features of the program that were easy to extend. For example, it was very simple to add outlines to the program (although this was done through a global static boolean). It was also very easy to add and initialize new simulations to the game. It was also easy to extend the grid. The hardest thing, although we tried to implement it, was adding functionalities to the simulation while it was running including scrolling, and dynamic changes to the variables. 

Example Class 1:
Simulation.java superclass. I liked this code because it used inherency, something that is usually a good design idea. I also liked it because although I did not spend much time reading the actual methods, it was easy to tell what each was supposed to do based on the name of the method. Like loopthroughcells obviously looped through the cells. I would suggest, however, making the logic of the code a little more readable. Althuogh I could tell what each method was for, I was never really sure how they all fit together. I had to ask the author of the code multiple times for the information that I needed and where to find it. This code would be hard to make reusable in another project because it was specifically designed to program CA simulations so unless a future project worked with that, I would not be able to implement the class again. The idea used to build the class, however, will definitely be used again in the future.

Example Class 2:
Buttons.java. I helped to write this class, but I did not have anything to do with refactoring it. I felt like this code could have been split up into very many subclasses, and I think the design of this code reflects that, a bit. There is a class called AlertBox.java which solely creates an alert box and can be used in any context, which I feel is the purpose of creating classes in java. I chose this class because I feel like it should have been split into many little "alert box" type classes. That way, in the future, if I were to be in charge of the GUI again, I could simply take the code I had written for this assignment and reuse it. That would be my suggestion for improving this code, and making it reusable in the future. What I learned about design from this code was that it is really easy to figure out what to change when you have the buttons in separate classes (re: the alert box) but not so much when it is all meshed within methods within the class. When adding some of the features, including the "show outline" checkbox, I spent a good 30 minutes perusing the code, trying to figure out where I was supposed to insert it. On second thought, I probably should have made a "checkbox" class. 

###Design
The overall design of the complete program is a little convoluted but still overarchingly simply. It is divided into the front end and the back end, and connected in the center by the grid. As the person who had the heaviest hand in dealing with the grid, I feel like I have a more complete picture of how our code is organized. The backend consists of two major superclasses and the subclasses below them that dictate the rules for each simulation and what type of cell each simulation contains and a generic step method inside the superclass. Each step method returns and updated String[][] of the colors of the new grid. The step method then updates the grid, so that it looks like the cells have moved, when in reality, only the colors have changed. We decided on this design aspect because it was simpler than trying to change the locations of all the cells, and when it came down to it, all cells were basically the same. The color was the only difference and we could use the current color of the cell to tell where the cell needed to go next. The frontend relied heavily on each other. The three main methods that made up the front end were the GUI, Buttons, and Grid classes. I was happy to see that our main method didn't contain much at all, just the start function calling the GUI and the launching of the game. 

To add a new simulation to the game, you would need to create a new simulation subclass with all the of the rules for that simulation, then create the cell subclasses for the types of cells used in that program. Then you would have to create an XML file for the simulation, containing the colors of the cells, the parameters needed by the rules of the cell, the name, author, and title of the simulation, and the shapes that could be implemented for the simulation. The you would add the simulation to the dropdown option in the buttons class, so that it could be picked, write a method for initializing the colors in the Color Matrix class. Then it was a simple matter of choosing the simulation from the drop down menu and the simulation should be playable. 

The code is designed the way it is based on the way we first understood the simulation. We decided to simply update the colors of the grid for the effect of looking like the cell positions had changed because it gave the same effect but required a lot less coding and was easier to manipulate. As a result, our code might have lost some of its roundability (aka ability to be used in other programs). 

There are a few dependencies in the code that impact the overall design of the program. As I've stated before, as we neared the end of implementing new aspects of the program, we wanted to mess up the code as little as possible and in some cases, settled for using global static variables to get things to work. For example, we thought it would be fine make the variables from the parser into global static variables because they would never be changed later on in the code. When we read the extensions of the program, however, we realized we would be hard pressed to be able to have the user dynamically change the XML file due to the way we were reading in the information. 

Feature 1:
Simulation superclass. The simulation superclass required the ColorMatrix class and the Grid class to be implemented. The superclass was made abstract, but had a few methods in it that were shared among the subclasses, namely looping through the cells and the step method. The rules of each simulation were defined in the subclasses, so those are pretty closed off from the rest of the programs. They made assumptions as to the type of grid it would be (2D, not 3D), and also that the neighbors would only be in the 8 cardinal directions (for rectangles and squares) and 6 directions (for the hexagons). I would describe this piece of code as moderately extensible in the future, given if we wanted to make new simulations. I would recommend making the class more readable and cleaner in terms of getting across how the simulation classes work within themselves and the cell classes. 

Feature 2:
Another feature we implemented was the toroidal graph ability. This we did by updating the neighbors each type of cell was allowed to have. It did not require any additional classes, just a few more if statements. The neighbors took two parameters, the current x and y location of the cells and then returned a list of neighbors to be checked. We had the check neighbors as its own class at first, but at some point the back end coder made the design decision to place it within the simulation superclass. This did not impact the code largely, because all of the simulation shared the same neighbor checking. The toriodal graph ability is an extension of neighbor checking, so when saying that this feature is extenisible, I am actually speaking for the neighbor class. I believe the neighbor class could be extended, but it would be hard to implement different types of neighbors that are not a mathematical function away from the current cell. 

###Alternate Designs
At one point, we were seriously considering going in another direction with our design. We were told by another TA that the cells themselves should be inherently movable and that the grid should be updated based on the cell's new locations, not just by changing the colors of the cells. We decided against this after a lengthy discussion in which we realized that we should trust our original design since it was able to accomplish everything outlined in the project outline. Although I think that the other road would not have been bad to take, it would have been harder to implement, but definitely more robust in the long run. The original design handled the project's extensions to the original specifications pretty well. There was nothing that had to be changed that we weren't already planning on changing for other reasons. 

Design Decision 1:
Not using the cells to update the grid as mentioned above. We simply felt that if we changed our code so much at so late a stage, we would end up not accomplishing as much, even if it was the right coding decision.

Design Decision 2:
Using a String[][] to update the cells instead of Cell[][]. This decision was made early on in the project timeline before we had the discussion with the TA. We had actually considered using a Cell[][], but then realized how hard it would to call and pass in the Cell[][] from different functions. Thus, we settled on a String[][]. The current design is not as robust: you cannot change many things from the grid, and everything must go through the simulation, but on the other hand, it is easier to call in the update function in different methods. 

If we had more time, I would have preferred to use the other design, if only because I feel like it would have made our code more robust and accepting of changes. I would also have liked to make more use of the XML. We made the decision not to include the states of each initial cell in the XML (mostly due to the way it was set up), but I feel like we could have implemented a lot more information in it (probably because I was in charge of it).

The two best features of the project's current design is how we set up the main function with the GUI, Grid, and Buttons, and the inheritance hierarchy that we implemented for the simulations. 

Two important issues that remain in the project's current design are the backend ways of getting information in between the classes, and the fact that some classes really should be split into more (and into packages).

#Code Masterpiece

I chose to refactor this class because when I was writing it, I really hated the redundant for loops that occurred at the beginning of every method. I thought about refactoring it so that there was a Color Matrix factory where all that would be done is calling the appropriate color matrix, but didn't feel like there was enough code functionalities for that to be worth it (all color matrix does is give the initial string[][] of the colors to fill the grid with). I still didn't like how each function began with declaring a string[][] and two for loop (exactly the same for each for loop), but while I was coding, I didn't have the time to change it. Instead I made a mental note to come back to it when I had time. I've changed it now so that if I wanted to, I could create a ColorMatrix superclass and each subclass would call in the same variables to populate the grid. I also split up one of the methods into a main method and helper method for that purpose. The reason why I did not implement inherency for this class was because of its limited use. I saw no reason to create so many classes when each class would only contain one method. Part of the reason why I believe in this code is because I feel like I chose the best compromise based on what the class was supposed to be accomplishing, how much code it contained, and what we had learned in class about good design and when to use what design structures.

> Written with [StackEdit](https://stackedit.io/). 