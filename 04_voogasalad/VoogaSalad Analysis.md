
#Project Journal

###Time Review

I spent a lot of my time thinking for this project. Since this was a very involved project, whenever a new feature was being added, or old ones were being refactored, we had to be very careful not to break any existing code irreparably. This meant that large refactorings (ie, complete overhaul of the design of our project) was very unattractive once we had set up an initial design. As such, for all the work that I was given, I would say I would spend a few days just thinking about the ways I could implement the features, or change existing features, without causing too much of a negative ripple effect in the overall code. This meant I spent a lot of time looking through code as well, searching for methods that I thought I would need to use, or investigating if an idea I had had already been implemented by someone else. Including time I spent thinking, I would say I definitely spent about 15 hours a week on this project, and some weeks more (although I don't think my commits on github show for this, because when I did code, I would say about 1/2 was pair programming on someone else's computer - the reasons for this I will get to later). Then, when I thought I had a solid idea, I would usually sit down one day, and just code everything that I had thought/written out over the last few days, debug, and try to make a commit. 

I personally managed my code by writing my own main functions to test them. I did not write JUnit tests, although I tried in the beginning. I found that for the information that I wanted to get, and for debugging purposes, writing my own main function was much more efficient and helpful. I deleted my testing classes before any commits.

Actually the tasks that were the hardest for me to do were the ones that were given to me by other people who already knew how to implement those tasks. I think it had to do with the way they were presented, because I wasn't given a problem about design so much as a set of instructions to follow. When I had to follow other people's designs, instead of being able to think of my own, like "implement a check for this", or "pass this information to here", I could do it, but it would take me a long time because I was not as well-versed in that area of the code as the person themselves. It was much easier to just be given a problem, and no instructions (although I did appreciate the help, and I know they were just trying to make it easier for me; unfortunately, I can't comprehend code just by having someone else tell it to me). For example, when I implemented levels, I took that from beginning to end by myself, and I knew exactly what to do, because I had spent hours looking through the code, and thinking about exactly what methods were needed, and where. As such, I was able to create an implementation that didn't change the existing architecture very much at all. Also, it is easier for me to think upon the pros and the cons of the design when I have had time to think it through. When I was told to implement something without being given time to do it, I would often implement it, then think about why it was good design or bad design. 

I wouldn't say it was a bad use of my time, but looking through other people's code and trying to figure out where certain variables were being initialized, or where methods were being called, or where information was coming from, definitely took up time. It's always easiest to ask the people themselves directly, but when I wasn't able to do that, I definitely noticed how much harder it was. Good uses of my time were just the times when I was thinking about how to design my part of the project because I did not have to be in front of a computer for this part, and could do it whenever.

Something that I deeply regret for this project is that I was not present at the initial design meetings because they were held on days in which I was out of town for interviews. Although I didn't think it would be that big of a deal at the time, it later turned out to be really hard for me to catch up to the rest of the team even though I knew what the design was, after having helped write the Design document and having my fellow teammates explain the decisions that were made while I was gone. I think the reason why it turned out to be a big deal was because I was not there for the discussions about different implementations, different approaches, the pros and the cons, and wasn't able to be as invested as the others were from the beginning. Also, they doled out roles in the first meeting, and I thought they would just assign me something of my own, but they ended up pairing me with a teammate to work together. Thus, I didn't commit fully in the beginning because I had nothing to think about. But I tried really hard to make my way in. I'm one of four members who worked on the game engine. In the first two weeks, I met with each of the members to see what they were working on, and to talk to them about what I could work on. Finally, I came upon characteristics. What sucks though is that all my work was refactored later because characteristics came to be used in a different way.

I think I underestimated the size of this project. I thought that since we had so many people, there was no way we couldn't get it done, but it ended up being a lot more involved that I had originally thought.

We had a lot of get togethers at Wannamaker. The team dynamic was very much come when you want, leave when you want, sort of thing. I've always been better in teams where we had to meet up and had set times to do so. Otherwise, I definitely prefer to do my thinking elsewhere. Whenever I had to sit down and code, however, I would join my teammates in Wannamaker. Efe was the team leader officially. He, Sally, Joy, and I worked on back end (game engine) together in the beginning. In the beginning, I didn't really have a part on the game engine except to work together with Joy. I didn't want that really because I had already missed the first design meeting, and sticking with Joy would mean I would have no responsibility in terms of design. So, I asked Efe first, then Sally, and Sally told me that she could use help with the characteristics part of the game engine, so that is what I focused on for the first part. I helped her design and implement the characteristics, and how they would be passed and initialized, and how players would "get" characteristics, and such. Although my part of this project was later refactored away (I had written a characteristic factory using reflection to instantiate all the characteristics, but Sally wrote a more generic one that she used for everything), at least I can say I contributed to the design by proposing the use of maps to pass characteristics around.

Front end was Karen, Ying, and Mike for GAE front end, and John and Daniel where GAE backend. Ted was on GamePlayer by himself. I thought that the communication of the team was very much if you needed to talk to a person, you would find them and talk to them. The general communication would be PSA's about working in Wannamaker and gitblames, but other than that, I would say communication occurred on a need basis. Personally for me, I work better with a stronger team lead who lays down times and places that people need to be. I definitely loved being able to decide when and where I worked, but as a result of that, I spent less time with the group than I think a lot of the other group members. We had vague deadlines for everything, but always ended up pulling allnighters the day before the class deadlines to get everything implemented.

Looking over my commit messages, I think they accurately represented what I was accomplishing. I took responsibility for characteristics and levels. Characteristics, I would not say I "finished" because what I did for characteristics was later not used. Levels, I would say I finished.

For levels, we were implementing this feature after the architecture of the game engine was pretty much set in stone. This meant I had to find a way to implement it without changing the existing architecture of the game engine. So to being with, I spent a lot of time thinking about what that meant and how that was supposed to be done. I asked my teammates a lot about where I could find certain information, and ultimately found that Ted on the GamePlayer side was the one who I would have to work with the most heavily. I talked over ideas with him a lot, and then when I had the game player part implemented, I talked with John about how the GAE would pass in the features that I needed. So I went person to person as I worked and had them work with me (this is where pair programming came into play). After it was initially done, I found out that we had to provide transferability of characteristics between levels. This caused another problem because the game level engine was basically coded to be a game engine by itself. 

I would like to think I contributed to the effectiveness of the team. In reality, I probably wasn't the most helpful member. My team was made of a lot of very strong coders, and as I am not as strong, it definitely took me a lot longer to code things and debug than my peers. Everyone was very patient and took time to explain if I ever asked something though, so I never felt like I was holding them down. I think for the rate at which I code, I took on as much responsibility as I could before I would fail to deliver. I tried to keep the team informed about my progress, but because the classes that I made ended up being an intersection for the GAE, GameEngine, and GamePlayer, any changes I made were known about anyways. I would say the GameEngine and corresponding interfaces require the most editting because everyone was adding functions and passing around parameters through that class and its interfaces to get information. The class became convoluted very swiftly, and sometimes it's hard to remember exactly what each method returns when there is so much information contained within the class, and which interface the method exists on. 

To be a better designer, I need to code more. After working with my team, I've realized that I have not coded to the point where coding is second nature, and my concentration is on design. My slowness in code definitely held me back in contributing as much as I could to the team because oftentimes, by the time I had figured out how to implement something, somebody somewhere else had already done it before me because they needed that function or feature. 

To be a better teammate, I should try to spend more time with the team. I don't actually get my most effective code done during those times, but it was always fun to joke around with them and be able to ask questions without delays. Most of my planning and designing, however, definitely occurred outside of those times.

If I could work to improve any aspect of the project at this moment, it would be cleaning up the interfaces and creating clear lines of communication between the different sections of our code. I spent way too much time digging through deprecated methods and duplicate methods.

###Design Review

Status

We tried to keep the code consistent in terms of naming conventions. Names for methods and variables can get quite long because we wanted them to describe what the method did or what the variable stood for. Abbreviations were frowned upon because they caused confusion about what they were abbreviations for (are params parameters or paramedics?). We also implemented a system of calling abstract classes "A" followed by the name and interfaces "I" followed by the name. This was followed 90% of the time because there were actually two ways that were used to name interfaces, one being the one described above and the other being OriginatorToDestinationInterface (ie, GameEngineToGamePlayerInterface). Some people added comments to their code, mostly GamePlayer (so Ted), but generally people left their method and variable names as explanation. Comments were generally put at the top of classes to describe the entire class' function. 

To answer if the code is readable or not depends on which section of the code is being read. I would say the front end stuff, which is a lot of setting of paddings and other semantics is not as readable as backend which is full of logic. For example, I think the gameEngine package is very readable because it consists of many smaller classes that have small methods. Only a few classes in the gameEngine are large, and those classes are usually the consolidators of information (ie, GameLevelEngine).

We did use a lot of interfaces and get methods in the coding of this project, particularly to pass information around without giving each class access to the entirety of other classes (we wanted to limit how much of each class we were exposing to try and keep accidental changes from happening). Other than lots of interfaces and get methods, I would say that the dependencies in our code are very clear, and it's easy to tell which get methods are used based on the inherited interfaces declared at top of classes. 

The gameEngine in particular was made of features that were all easily extendable, from map objects to characteristics to actions to rule to conditions (all of which are a type of map object, which just goes to show how extendable everything in the game engine was!). The entirety of the project was made to be very extendable so many classes are actually extensions of another abstract class. Features that are hard to extend would be ones that are very niche, like the networking capability or features that would apply only to the Gucci game engine like particular rules and outcomes. 

I liked the class TypeMap even though it is very short. It was interesting to me because I would never have thought to create a map that returns a type. More interestingly is how Sally used it in her factories. She declares it in three of her factories, but doesn't seem to do anything with the map. I thought it was meant to be a type check, to make sure the class that was being created was initialized with the correct type of variables or something like that. It is a very interesting data structure that I would love to incorporate into my own code in the future, although applications for it as of now I think are either going to be for casting variables or type checking. I think this code is reusable by itself, no changes necessary.

Another class I will talk about is AGaeDialog. This is an abstract class that the Gae dialogues all extend. I chose this code because I think it's one of the few abstract classes in our program that does something other than act as a superclass for a bunch of other classes. The alert box actually exists within the abstract class, so none of the classes that extend from it have to implement it. Thus, they can take the information from the alert box and save it in the way that they want. I liked this class because of what it says about design: although the information coming in might be completely different and what you're doing with it might be completely different, you can still take in all the information in the same way. I would definitely use this abstract class in the future, in a situation where information was being given through user input and parsed in different ways. I feel like its following the Strategy design pattern, but uses an abstract class to connect the client and the different algorithms versus an interface. 

The last class I'll talk about is one I had to peruse through a lot: GameController. This is a very large class, and one that (as the name suggests) controls the game. It's where engines are loaded and switched out. The reason why I chose this class is because I think it is a good example of how large classes should look. The methods are all pretty small and straightforward. It is easy to follow the flow of logic in the slightly larger methods because they all call submethods as well. Since I spent so much time trying to figure out exactly how levels would be implemented by the GamePlayer, I was really grateful to have a class that was so easy to read. This code would probably not be able to be used in another project as it was directed towards this project. Something interesting I think I learned from this class is that code can be read, and sometimes, spacing is what makes the difference.

Design

Well, the program is basically made up of the four parts defined in the prompt: GAE (game authoring environment, game data, game player, and game engine). The overall design of the program is as such: Game Authoring Environment is a separate GUI that allows the user to create a game from scratch. This means creating a new Game Level Engine (each game, is technically a level). The GAE then saves the Game Level Engine as an XML file in Game Data to be loaded by Game Player, which has its own UI for playing the game. 

The Game Authoring Environment actually consists of multiple sub units, that come together in an MVC design pattern. The view is called GAEGui, and holds all of the javaFx used in this project for MapObjects and MapObjectTypes. The information from the view is then passed on to the model to the controller, adeptly named GaeGuiController. In the model, you can continue to modify objects. The GAEModel holds all of the maps and lists of the game rule data and other variables for the game. It is where existing games can be loaded to edit or new games are saved to XML. All necessary game data is then passed on to the Game Player through a wrapper class. The highest wrapper class is GameInfo because it contains both the GameEngine and GuiData that the front end uses (as shown above, GuiData is part of the classes GAEModel uses to host information). Through an interface, information is then passed on to the GamePlayer to intialize games using the GameEngine. The GameEngine and the GamePlayer also interact through interfaces, although on many different levels. The overall game is hosted in the GameEngine. The GameEngine holds all instances of GameLevelEngines for the game that will be needed to play each successive level. Each GameLevelEngine is the class that the GAE actually interacts with when creating games, so that is where the GamePlayer loads the needed player information from. 

I contributed to adding the levels feature significantly. I thought this was a very challenging design question because I had the restriction of not being able to change current architecture as too much of the program had been written before we realized we had to implement levels. Another challenging design question was how, because our game engine was coded to be a stand by itself game, would we pass variables between levels. At first I thought abstraction would be the answer to my problems, I would just add a layer of abstraction to the GameEngine and then have all further GameEngines extend from that, but I quickly realized that was not going to solve the levels problem. It would have allowed us to implement different types of game engines, but that was not what we wanted. We wanted to implement multiple instance of a single game engine, with different variables and data being loaded in each time. Thus, what I created was a wrapper class that used composition to host the different game level engines. Then to add the feature of transferability, I created another class to save data between levels that could be called upon between the loading of levels to initialize or reinitialize data based on past levels. The whole of my design was based around the idea that I could not change the current architecture of the game engine or the way the different parts of the program was interacting with each other by too much. There are some assumptions, such as one level will only lead to another level and the user cannot pick with level they would like in between (unless the user creates a new game, then the user can pick a new starting point). 

I did not implement rules or conditions or movements. These are all implemented in the game engine, which I was a part of. However, when working on the game engine, I focused mainly on characteristics. These features are all based on the communication parameters of the game engine, which is how information was passed between game engine classes and the game level engine. At a high level, the rules, conditions, and movements were all just abstract classes. That's what tied them together. For example, for rules, each class had to implement executeRules(), which depending on the class would be different. Players could then be "given" rules, moves, conditions, actions that they could choose from/had to follow. That is the basis of our design. Because of this design, it is extremely flexible because we can code any type of action or rule or condition that we want. At the same time, however, it becomes very wordy when we want to have a specific game with certain restrictions.

I think we could have done away with some abstraction and the robustness of our code and gone for something more concrete, aka defined our terms a bit more. We kept everything so general, that it actually became harder to create a turn-based strategy game. In fact, at one point we were joking that we would just create a tower-defense game because that's how broad our game engine is. All that is needed is specific groovy-created classes that would define the rules and actions and such for the game, and we could have a turn-based strategy game. 

I think the flexibility of our game engine is something that is truly awesome about it, but also a double edged sword because it makes it hard to 


###Code Masterpiece
describing the component's purpose and why you think it is well designed

I think my coding masterpiece improves upon the current design of levels. At the moment, levels are decided based on what the condition "EndLevel" returns as the next level. If there are no levels left, "EndLevel" will return a default that will let the GamePlayer know to return to main menu. However, this only allows for a linear, one to one level mapping (which I didn't think of when designing levels the first time around). Basically, once a game has started, players would be required to move from one level to the next, with no choice as to what or where they want the next level to be (the only control they have is setting the level order in the GAE when creating the game). However, this is still limiting in that one level can only lead to one level. The purpose of this component is to allow for more flexibility in choosing levels, and the mappings of levels to each other, as well as take the setting of the next level out of the game level engine since I don't think it belongs there. I think the game level engine should only be aware of its own state because it is just meant to be a level in the game. Due to our original design, it is created like an independent game, and as such, should not have dependencies within the game level engine itself. Decisions like where to go next and what information to pass on and such should be made by the game engine, which is the larger wrapper class, coded in GameData. For example, in a game like civ, levels could be such that you can only conquer parts of the world at a time. You could start out with a default level, but depending on your resources and your choices, or depending on what you choose at the end of the level, you could go on to conquer the sea, the air, outer space, etc. In these cases, I want the class to be able to take in the outcomes OR user choice and return the next level to the game player. The game level engine should have no clue what is going on because that is outside the scope of its functionality. I think extracting this decision from the game level engine is good design because it is getting rid of dependencies of the game level engine, and allowing for a more robust system with more options. It follows the strategy design pattern so there could be multiple ways of choosing the next level, and the game player would never have to know any different. Furthermore, it helps with keeping classes from trying to do too much, and helps each class have only one main purpose - outcomes only tell outcomes, not next steps, and the game level engine only plays the level, so it also keeps the code from getting too complicated. Furthermore, the refactoring also gives the game engine and game stats classes more clarification and division. Since game stats was added later, many variables that could be considered information about the game were added directly into the game engine class, when they should have been in the game stats class (is the game engine information class, which is really confusing I know because GameInfo also exists - I have the worst naming abilities ever. I'm trying to work on it, I promise). I realize it doesn't seem like much changed but it took me a while to think of a good implementation for this. I was considering a resource file or a map of integer to string along with the one that already existed so I think this is a good alternative. Furthermore, I think it allows for a broader spectrum of expansion, and more complex games to be built, while not having to worry about if the correct strings are being passed into EndLevel, and where they're getting set and when they're getting passed and so and and so forth.

###SLogo Addition
Since I worked on front end exclusively for SLogo, I implemented the one additional feature given: a new view that allows users to see images of all turtles (active or not), that also allows for changing a turtle's image upon click. 

####Estimation
I think it will take me a few hours to complete this new feature. It's been a while since I looked at the code, and although I remember superficially how everything works, I don't remember which classes hold what functionalities specifically anymore (aka, I don't remember where we update turtle images, etc.) so I'll have to take a look through the code and analysis I wrote for this project and reorganize my thoughts. I think I'll have to add one class and one resource bundle for the new component in the front end. I'll also have to update TurtleView to include the new component since it is the controller class for the front end, but that should be all the files that I need to touch because of the way the front end was implemented in the first place: it was meant to be very extensible and to have each feature be as individual as possible, so that it would be easy to remove and add further features. 

####Review
I did it the quick and dirty way, so there might be edge cases that I did not think about. True to what I estimated, it took me a few hours to complete this new feature. I don't think it is the best possible implementation, especially because the Turtle on the screen only updates once there has been a move acting on the turtle. I definitely did not get it right on the first try. I forgot what one of my classes was, and thought that was the class that I should just add click functionality to, before I realized it was a list of the turtles that we could choose from (TurtleTable). Then I had to revert my changes. Like I guessed, I ended up creating a new class and adding a new resource bundle and adding a few lines of code to TurtleView. I think I might have messed around with TurtleDrawing a little, but that was to see if I could get it to update in realtime. I don't think I changed any of the actual code, however. 


####Analysis

I think this project shows that we had a very well designed front end. It was easy to add a new component to be shown, and easy to add functionality to it. However, it also shows that my documentation skills have much to be desired. I liked this mini project because it is the first real proof of the use of documenting my code and the purpose of my analysis. It gives me reason to do better on documentation in the future. I thought that the front end was actually not as well designed as I remembered. It was definitely easy to add new features, but each feature that I added required a lot of excess information about it that I didn't think every feature should have. Given the time, I would like to think about how I would change it around so that the code seems a little more simple, and not like you have to follow a set of instructions each time you add a new feature. If I had not been familiar with the code at all, I think it would have taken me much longer to figure out how the click functionality would have worked and how to add a new component to the screen. The way to add a new component to the screen is not intuitive at all.

> Written with [StackEdit](https://stackedit.io/).